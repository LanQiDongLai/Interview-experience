# FAQ
### 信号的生命周期？
信号可以从键盘输入，时间片耗尽，硬件异常，软件层面产生，然后信号会存储到未决信号集(pending)中，当进程从内核态转换到用户态时，会检查掩码与未决信号集，如果有信号产生，那么进程会将信号从未决信号集中卸载该信号，那么就调用信号处理函数（如果有注册的话），执行完信号处理函数，那么信号对于该进程的影响将会彻底结束
### 信号的产生方式？
1. 终端上的键盘输入
2. 硬件产生，除以0，非法访存
3. 系统调用函数，kill
4. 软件层面，SIGPIPE，SIGALRM
### 信号处理方式？
1. 忽略信号，缺页异常，子进程结束
2. 用户自定义函数，在产生信号之前向进程中注册信号捕捉函数，在产生信号后，进程会执行已经注册的信号函数
3. 系统默认处理，绝大多数信号系统默认都是去终止该进程
4. SIGKILL，SIGSTOP总是执行系统默认处理方法
### 如何消除隐式转换？
在类类型转化中，使用explicit（清晰的）在构造函数之前会消除隐式转换
```cpp
class A{
public:
    int val;
    explicit A(int val){
        this->val = val;
    }
};
/////////////////////////////////
A a = 1;//报错，无法从int类型转化为A类型
        //如果取消explicit修饰符，那么编译器自动将该语句转化为
        //A a = A(1);
//这样做的好处是，防止代码中因为隐式转化而在构造、传参过程中发生不必要的误解
```
### 重载，重写和隐藏的区别？
1. 重载是全局或同类中的行为，如果同名函数具有不同的参数列表，那么在调用函数时传入不同的函数参数，则编译器会自动对应到与之匹配的函数参数
2. 重写是父类与子类之间的行为，当父类中定义虚函数，同时子类定义同名的虚函数（参数列表一致），那么子类生成的对象就会覆盖原来的父类的函数
3. 隐藏是指不同类中，或者是不同的命名空间，在该类中调用此函数，与别的类中的同名函数是没有任何干系的
4. 重定义（隐藏），父类中的成员函数在子类中有相同名称的定义（参数列表可以不同），那么父类中的成员函数就会被隐藏，只有显式的定义才会调用父类的函数
```cpp
//重定义
class A{
public:
    void func();
};
class B: public A{
public:
    void func(int val);
};

B b;
b.func();//出错，没有匹配参数列表
b.A::func();//正确，显式的调用父类函数
```
### volatile表示什么？有什么作用？ 
volatile用来表示这个变量的值随时都有可能会改变，不要将此值传进寄存器来优化
```cpp
volatile bool flag = true;
while(flag){//不加volatile，编译器可能会将此处直接优化为while(true)
    //...
}
//Other Thread
flag = false;
```
例如，在多线程环境中，一个线程中的值似乎不会发生任何改变，编译器可能会选择将上下文中所有用到此变量优化到寄存器中，那么其他线程想要改变该值，就会在结果上发生错误

### static_cast<>,dynamic_cast<>,const_cast<>,reinterpret_cast<>的各自作用和使用环境？
1. static_cast
   1. static_cast类似与强制类型转换，但是，static_cast不会去去除const属性，volatile属性，将值类型转化为指针类型，指针类型转为值类型
   2. 可以转换基础数据类型，int，float，double，char
   3. 可以转化指针/引用，但是两个指针/引用之间所属类型必须有着继承关系
   4. 可以将任何类型的指针转化为void *，void *转化为任何类型的指针
2. dynamic_cast
   1. 只能用于指针和引用，指针只能转化为指针，引用只能转化为引用
   2. 对于转化的类型必须具有虚函数表
   3. 会进行下行转化的检查，查看该父类指针是否可以转化为子类指针（检查是否在初始化时为子类），若不能，则返回为空指针
   4. 交叉转化的时候，dynamic_cast是允许的，但是static_cast是会在编译时期报错，结果返回为空指针
3. const_cast
   1. 用于将有const和volatile修饰的指针或变量转化为没有const和volatile修饰的指针或变量
   2. 只能传递指针或引用
   3. 只能调节限定符，不能更改类型
4. reinterpret_cast
   1. 仅仅只是处理对于指针所指向的值的一种映射，将指针所指空间的二进制数据强行转化为其他类型指针所指向的空间
   2. 只能传递指针或引用
   3. 所有转换中最危险的，相当与全部转化为(void*)再转化成其他类型
### malloc和new的区别？
1. malloc概念上是对内存空间的分配，按照字节数分配内存，new是对类型的分配，按照类型创建内存空间，同时会调用构造函数
2. malloc使用free释放内存，new使用delete释放内存
3. 当malloc调用失败的时候会返回NULL，而new会抛出bad_alloc异常
4. malloc会在堆上创建内存，new会在自由存储区（编译器一般作为堆区）上存储内存
5. new，new[]可以重载
### free和delete的区别？
1. free对应malloc分配的内存，delete对应new分配的内存
2. delete\[\]会对应new\[\]分配的内存
3. delete，delete[]可以重载
### free一个数组时如何知道要释放多大的内存呢？
在malloc时，会在返回的内存空间前面加上头部，其中保存了分配内存大小的信息，在调用free时，可以在指针的前几位中找到内存块大小，会将malloc头部和内存块一同释放
### __stdcall和__cdecl的区别？
不同点：  
__stdcall由被调用者返回时自动将参数从栈空间中清除，__cdecl由调用者将参数从栈空间中清除  
由于__cdecl是由调用者将参数从栈中清除，所以在使用变参函数时，必须使用此函数调用方法  
相同点：参数都是从右向左入栈
### linux内部提供了那些调试宏？
    __TIME__       显示当前时间    类型%s  
    __FILE__       显示当前文件    类型%s  
    __DATE__       显示当前日期    类型%s  
    __LINE__       显示当前行数    类型%d  
    __FUNCTION__   显示当前函数    类型%s  
### 手写线程安全的单例模式？
```cpp
DCL 双重锁定检查
class Singleton{
private:
    static Singleton* instance;
    static std::mutex mtx;
public:
    Singleton(){
        std::cout << "Newing" << std::endl;
    }
    static Singleton* getInstance(){
        if(instance == nullptr){
            mtx.lock();
            if(instance == nullptr){
                instance = new Singleton();
                mtx.unlock();
                return instance;
            }
            mtx.unlock();
        }
        return instance;
    }
};
Singleton* Singleton::instance = nullptr;
std::mutex Singleton::mtx = std::mutex();
```
### 引用和指针的区别？
1. 引用初始化的时候总是需要绑定一个对象或变量，所以不存在空引用或野引用，但是指针存在野指针或空指针，故引用相对更安全
2. 引用绑定一个变量或者对象之后就不能再改变，而指针可以再指向下一个对象，故指针更灵活
3. 有些时候，一个「引用」不会在被创建时就已经指向一个确定的对象，如链表或单例模式中的实例，在这种不是第一时间绑定的「引用」必须使用指针
4. 编译器在处理引用的大小(sizeof)的时候，会获取所引用的对象的大小，而指针只能获取其指针的大小(32位4字节，64位8字节)
5. 引用相当于Type* const(指针常量)
### 出现异常时，try和catch做了什么？ 
try中语句中发生异常时，catch会捕捉到该异常，并终止try中后续语句的执行，跳转到catch中的语句来执行
### C++如何处理多个异常的？常对象的成员变量一定不可以修改吗？为什么？
1. catch后括号中写上异常类型，当该类型异常抛出时，就由该catch语句块来执行，当括号中为三个点时，表示捕捉所有异常
2. 不一定，当常对象成员变量存储在常量区中，那么该成员不可修改，如果该成员是由C++标识符const所修饰的时候，那么他实际上是在栈区中，可以通过const_cast绕过编译器检查进行修改
### 虚函数的调用过程？
在具有虚函数的对象中存在一块指向虚函数表的指针，在调用虚函数时，会使用指针所指向的虚函数表，通过查询可以得到函数实例
### 单继承，多继承，菱形继承，虚继承时，对象内存中的差异区别？如果存在虚函数呢？
https://www.likecs.com/show-204168790.html
### 实现一个vector？是1.5还是2倍，各有什么优缺点？
### map底层用了什么？
红黑树和pair键值对
### 如果用map删除了一个元素，迭代器还能用吗？为什么？怎样做可以接着用？
不可以，因为迭代器所指向的红黑树节点被删除，红黑树也会出现相应的调整，所以迭代器失效  
erase方法会返回下一个节点的迭代器
### 红黑树的特征是什么？
1. 属于二叉树
2. 根节点必是黑色
3. 叶子节点(NIL)必是黑色
4. 不存在两个连续的红色节点相连
5. 从任意一个节点到它所有可达的叶子节点所经过的黑色节点数目必相同
### 红黑树如何插入和删除的？
### 红黑树和B+,B-的区别？
### 线程同步几种方式？
1. 使用mutex作为互斥锁
    1. 互斥锁（当一个互斥锁未上锁时，在执行到lock时可以对其上锁并继续执行下文，当一个互斥锁已经上锁，那么该线程会在lock处阻塞，并直到互斥锁释放时继续上锁并执行）
    2. 自旋锁（与互斥锁类似，但是自旋锁并不是通过阻塞和唤醒的方式来处理上锁的，而是通过轮询的方式查看自旋锁是否已经释放）（当此处的锁并不会长期存在，而是在短时间内释放，由于阻塞和唤醒需要一定时间，所以使用自旋锁会比互斥锁效率更高，但是由于自旋锁是通过轮询的方式实现的，所以当一个线程长期自旋在锁处，会很浪费CPU资源）
    3. 读写锁（当写锁已经上锁，那么读锁处阻塞，写锁处阻塞）（当读锁已经上锁，那么读锁可以继续上锁，而写锁阻塞）
2. 使用cond作为条件变量
3. 使用sem作为信号量
### 手写strcpy,memcpy,memmove函数？
```cpp
char *strcpy(char *dest, const char *src){
    size_t i;
    for(i = 0; src[i] != '\0'; i++){
        dest[i] = src[i];
    }
    return dest;
}
void *memcpy(void *dest, const void *src, size_t n){
    size_t i;
    for(i = 0; i < n; i++){
        *((char *)dest + i) = *((char *)src + i);
    }
    return dest;
}
void *memmove(void *dest, const void *src, size_t n){
    ssize_t i;
    if(dest < src){
        for(i = 0; i < (ssize_t)n; i++){
            *((char *)dest + i) = *((char *)src + i);
        }
    }
    else if(dest > src){
        for(i = n - 1; i >= 0; i--){
            *((char *)dest + i) = *((char *)src + i);
        }
    }
    return dest;
}
```
### do{}while(0)的用法有哪些？
1. 在宏中使用可以将一段代码封装在一个块中
```cpp
#define FUNC() do{\
func1();\
func2();\
}while(0)\

#define FUNC2() \
func1();\
func2()\

if(...)
    FUNC();
//转变为
if(...)
    do{
        func1();
        func2();
    }while(0);

//而FUNC2会导致歧义
if(...)
    func1();
func2();//func2跳出if控制块
```
2. 配合break可以作为出错处理的跳转指令，代替goto使用
```cpp
do{
    //...
    if(func() == -1)
        break;
    //...
}while(0);
```
### 手写快排？时间复杂度？空间复杂度？能进行优化吗？还有吗？能进行尾递归优化吗？
### 线程池的作用是什么？
### pthread_cond_signal和pthread_cond_broadcast的区别
### TCP三次握手和四次挥手及各自的状态？
### TCP如果两次握手会出什么问题？那三次握手又会造成什么问题？有什么好的解决方法没？
### TCP四次挥手为什么要有TIME_WAIT状态？为什么？
### 死锁的原因？条件？如何预防？又如何避免？如何解除？
### 排序稳定的算法，你知道那些？
### 解决hash冲突的方法？
1. 链地址法
在C++ STL中，unordered_set对于hash值一样但是元素不同的元素，会将其元素串成链表进行存储（链地址法），当链表长度超过一定的阈值，那么就会将链表转变为红黑树进行存储，当红黑树中存储的元素小于一定的阈值的时候，那么就会将他重新转变为链表  
2. 开放地址法
   1. 线性探测法  冲突了就选择下一位，再冲突就选择下下位，以此类推
   2. 二次探测法  冲突了就选择平方取余后的位置，再冲突就继续计算
   3. 双重散列法  冲突了就选择其他hash算法继续运算，再冲突就继续计算
链地址法虽然简单易于实现，但是需要额外的空间来存储  
开放地址法不需要额外空间来解决冲突，但是容易产生聚集，导致哈希性能下降  
### unordered_set中所采用的hash方法是什么
在C++ STL中，unordered_set使用的是std::hash函数，它是一种通用的哈希函数，可以处理任何类型的元素。std::hash函数的实现是基于一种称为Fowler-Noll-Vo（FNV）哈希的算法。它通过将元素的字节按给定的方式组合，再进行一些基本的位运算和异或操作，生成一个哈希值。FNV哈希算法简单、快速，而且具有良好的分布特性，因此被广泛应用于哈希表的实现中。
### C++中内存分为哪几部分？
1. 栈区：存放函数参数，局部变量，还有函数返回地址
2. 堆区：存放动态分配的内存，堆区的内存需要自己手动申请和释放，需要程序员自己管理
3. 全局区：存放全局变量、静态变量以及常量，全局区的大小在程序运行前就已经确定好
4. 代码区（只读区，常量区）：存放程序指令（包括静态链接库中函数实现），在程序运行前就已经分配好
### 如果new申请内存失败了，如何去解决？如果让你实现一个new，你会怎么实现？
1. 当new内存分配失败了会抛出std::bad_alloc异常，可以通过捕获该异常来处理，处理方式按照具体情况来
2. 如果申请内存失败需要返回空指针而不是抛出异常，可以使用new(std::nothrow)代替
3. new是有编译器支持的关键字，如果只是在现有的语法基础上实现基础的内存申请功能，但是自动调用构造函数无法实现，但是可以使用placement new来对已经存在的空间进行构造函数的调用
### 如何得到一个结构体内成员的偏移量？
```cpp
/* 直接用0作为结构体地址然后取变量的地址 */
(size_t)&((struct Node*)0)->val;
/* 使用库函数 */
#include <stddef.h>
offsetof(struct stru, i);
```
### 进程与线程的区别？
1. 进程是资源分配的最小单位，线程是资源调度的最小单位
2. 线程是在进程下运行的，一个进程可以包含多个线程
3. 进程有自己的独立地址空间，每启动一个进程，系统就会为它分配地址空间，而线程是共享进程中的数据的，使用相同的地址空间
4. 同一进程下不同线程间数据容易共享，不同进程间数据很难共享
5. 线程之间没有单独的地址空间，一个线程死掉，整个进程也死掉，而一个进程死掉并不会对另外一个进程造成影响
6. 启动一个线程所需要的开销比启动一个进程的开销要小
### 逐层打印二叉树？
```cpp
struct TreeNode {
    int val;
    TreeNode* left;
    TreeNode* right;
    TreeNode() : val(0), left(nullptr), right(nullptr) {}
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
    TreeNode(int x, TreeNode* left, TreeNode* right) : val(x), left(left), right(right) {}
};
void PrintBinaryTree(TreeNode *root){
    std::queue<TreeNode *> que;
    que.push(root);
    while(que.empty() == false){
        for(int i = que.size() - 1; i >= 0; i--){
            TreeNode* node = que.front();
            std::cout << node->val << std::endl;
            if(node->left != nullptr){
                que.push(node->left);
            }
            if(node->right != nullptr){
                que.push(node->right);
            }
        }
    }
}
```
### 构造函数能不能虚函数？为什么？那拷贝构造函数能不能为虚函数？为什么？
虚函数是在运行时通过指针或引用来调用的，而构造函数在对象创建时自动调用，还没有创建出对象，因此不能通过指针或引用来调用。  
另外，构造函数的主要作用是初始化对象的成员变量，它在对象创建时调用，因此不存在多态的问题。
拷贝构造函数和构造函数是一个性质的问题，当然不能声明为虚构函数
### 析构函数能不能虚函数？为什么？
可以，使用虚析构函数可以让指向派生类的基类指针能够释放派生类所需要释放的资源
### 模板和实现可不可以不写在一个文件里面？为什么？
不可以，必须写在同一个文件里面    
C++中每一个对象所占用的空间大小，是在编译的时候就确定的，在模板类没有真正的被使用之前，编译器是无法知道，模板类中使用模板类型的对象的所占用的空间的大小的  
所有模板的类或函数的行为，都是在编译之后的实现中确定，相同的模板类或函数的不同实例在底层实现中都对应着不同的函数和类
### 什么是RAII资源管理？
RAII(Resource Acquisition Is Initialization)是一种C++编程技术，用于在程序中管理资源的获取和释放。  
这种技术的核心思想是将资源的获取和释放绑定在一个对象的生命周期中，即资源在对象构造时被获取，在对象析构时被释放。  
这样可以确保资源的正确获取和释放，避免资源泄漏和悬挂指针等问题。
### 为什么要字节对齐？
字节对齐是为了优化内存访问和提高处理器效率而采用的一种技术。  
在计算机中，内存是以字节为单位进行分配和管理的，而处理器在访问内存时通常是按字或双字等批量读取数据的。  
如果数据结构没有进行字节对齐，则可能会导致处理器需要进行多次内存访问，这会增加内存带宽和访问延迟，降低程序的执行效率。
### 在成员函数中调用delete this会出现什么问题？对象还可以使用吗？

### 如果在构造函数中调用memset(this, 0, sizeof(\*this))来初始化内存空间，有什么问题吗？ 

### 对一个数组而言，delete a和delete[] a有什么区别？为什么？ 
在gcc编译器中，因为空间释放和调用析构函数所使用的机制并不相同，所以delete和delete[\]都会直接将所有的空间全部释放完毕，但是delete只会调用数组中第一个元素的析构函数，而delete[\]则会按照数组大小依次调用所有的析构函数  
在C++标准中，并没有规定此种行为，对于使用new分配的空间，使用delete[\]释放和使用new[\]分配的空间，使用delete释放，其结果都是未定义的
### dynamic_cast是如何实现运行时类型转换的？ 
dynamic_cast的实现原理如下：  
1. 在编译期，dynamic_cast会先判断源类型和目标类型是否存在继承或虚拟继承关系。如果不存在，则无法进行转换。
2. 在运行期，dynamic_cast会根据待转换的指针所指向的虚函数表与目标虚函数表进行比对，如果是同一虚函数表，那么转换成功。如果不是，那么返回nullptr。
### C语言调用C++语法函数怎么做？那C++调用C语法的函数怎么做？ 
### extern “C”是什么意思？他有什么作用？ 
### 进程间的通信方式有哪些？线程间的通信方式呢？ 
### IO模型主要有哪些？ 
同步IO  
IO多路复用  
信号驱动  
异步IO  
### 阻塞和非阻塞？同步与异步的区别？ 
### select，poll和epoll的区别？为什么？

### struct{char a\[0\];}的作用？有什么好处？
可以用来作为柔性数组，虽然此结构体占用空间为0字节，但是如果使用malloc或new分配内存时分配size长度的字节数，那么该结构体的a数组就指向那么长度的单元
```cpp
struct Array{
    int size;
    char a[0];
}
int main(){
    //初始化
    Array *ptr = (Array *)new char[sizeof(Array) + 100 * sizeof(char)];
    ptr->size = 100;
    /* 内存布局 */
    //ptr-> |size|(Array)
    //      |char a[0]|
    //      |char a[1]|
    //      ...
    //      |char a[100]|
}
```
### 如何判断两个浮点数相等？
虽然他们的分数表现形式是一致的，但是会在运算过程中丢失精度，所以两个理论上一致的浮点数在使用==运算符时返回false  
可以使用fabs(float_a - float_b) < 0.00001来判断是否相等，而后面的数字越小所需要的精度越大，根据实际需求来判断
### 浮点数为什么会有误差？ 
浮点数在计算机中使用二进制存储，所以当使用浮点数表示十进制小数时，可能会在二进制的表示上舍去循环表示或精度溢出的部分，导致浮点数具有误差
### TCP的nagle算法和延迟ack，还有CORK呢?他们有什么好处？一起用会有什么效果？你觉得可以有什么改进？
### 栈上分配内存和堆上分配内存有什么区别？

### 变量的存储方式有哪些？
| 存储类别 | 描述 | 存储期 | 作用域 | 声明方式 | 
| ------ | --- | ----- | ----- | ------- |
| auto | 栈或堆变量 | 自动 | 块 | 块内 |
| register | 寄存器变量 | 自动 | 块 | 块内使用关键字register |
| static(局部) | 局部静态变量 | 静态 | 块 | 块内使用关键字static |
| static(全局) | 全局变量 | 文件内部 | 所有函数外使用关键字static |
| extern | 外部变量 | 静态 | 文件外部 | 所有函数外 |
### 线程私有和共享那些资源？进程私有和共享那些资源？
### 什么是守护进程？如何查看守护进程？什么是僵尸进程？如何查看僵尸进程？
守护进程是一个在后台运行并且不受任何终端控制的进程    
使用ps -axj指令查看进程，TPGID表示前台进程组，若为-1，则为守护进程
由于当子进程比父进程先结束，而父进程又没有回收子进程，释放子进程占用的资源，此时该子进程成为僵尸进程  
使用ps -ax指令查看进程，若STAT为Z，则为僵尸进程
### 进程同步机制？

### 什么是信号？
### kill函数的每一个参数的作用？
函数原型  
```cpp
int kill(pid_t pid, int sig);
```
若pid>0那么将sig信号发送到pid对应的进程  
若pid=0那么将sig信号广播到当前进程的进程组中  
若pid=-1那么将sig信号广播到当前进程所有有权发送信号的进程  
若pid<-1那么将sig信号广播到-pid对应的进程组的所有进程  
### 什么是协程？

### 虚拟内存实现有哪几种方式？有什么意义？
### 什么是类型安全？能举例吗？
### 确保线程安全的几种方式？
### OSI七层模型？
### TCP/IP五层模型？
### DHCP协议是什么？使用什么端口？他的优劣？
### 网络序是大端还是小端？为什么要这样？
### ping命令使用的是什么协议？
### 路由表一般包含什么？
### 停止等待协议的缺点？为什么？
### 拥塞控制的方式？具体怎么做的？快重传的时机是什么？
### DNS协议如何实现将域名解析为IP地址的？
### 创建进程的步骤？
1. 申请一个空白的PCB和唯一的进程标识号pid
2. 为新进程分配除CPU以外的资源,包括
内存空间;
3. 初始化PCB中的数据项,包括标志信息、状态信息、控制信息等;
4. 将新进程的PCB插入系统的就绪队列。
### 进程切换发生的原因？处理进程切换的步骤？
#### 原因
1. 阻塞式系统调用、虚拟地址异常，导致被中断进程进入等待态。
2. 时间片中断、I/O中断后发现更改优先级进程，导致被中断进程进入就绪态。
3. 终止用系统调用、不能继续执行的异常，导致被中断进程进入终止态。
#### 步骤
1. 保存之前运行的进程上下文
2. 调用准备运行的进程的上下文
3. CPU使用权交接
### 虚函数表是在什么时候确定的？那虚表指针呢？
虚函数表在编译时期时，编译器就已经为每个类确定了虚函数表的内容  
虚函数指针的结构在编译时期时，编译器就已经在类中插入了虚函数指针的结构了  
在运行期，虚表指针跟随对象的创建一并创建，并在对象中占据空间
### 如何检查内存泄露？如果不通过printf,debug等调试方式和编译器报错提示呢？
1. mtrace()函数Linux自带内存检测工具
2. valgrind工具，由内核（CPU模拟环境）以及基于内核的其他调试工具组成
### int(\*f(int,void(\*)()))(int,int)是什么意思？
这是一个返回int(\*)(int, int)，参数为int, void(\*)()的函数
### STL空间配置器如何处理内存的？能说一下它的大概实现方案吗？为什么是8bytes的倍数？
### HTTP 403表示什么？
资源不可用，表示服务器理解客户端的请求，但是服务器拒绝处理这一请求，通常是因为没有足够的权限访问资源
### 静态函数能定义为虚函数吗？为什么？
虚函数依赖虚函数表和虚指针处理，所以静态虚函数是不存在的
### 静态函数能定义为常函数吗？为什么？
不可以，因为静态函数不存在类成员，所以静态函数定义成常函数无意义，同时编译器也不允许
### 知道什么是幂等性吗？举个例子？
执行多次或多次累加的结果或影响相同  
在HTTP协议中，对一份资源请求的结果，和对此资源多次请求结果相同，不会额外的造成数据库的增删改操作
### 当接受方的接受窗口为0时还能接受数据吗？为什么？还能接受什么数据？那怎么处理这些数据呢？

### 当接受方的返回的接受窗口为0时，发送方会进行什么操作？
### 请求页面置换策略有哪些方式？他们的区别是什么？各自有什么算法解决？
### 系统调用与函数调用的区别？
函数调用是调用函数库中的一段代码块，而系统调用是调用系统内核的服务  
函数调用是与用户程序相联系，而系统调用是操作系统的一个进入点  
函数调用是在用户地址空间执行，而系统调用是在内核地址空间执行  
函数调用的运行时间属于「用户」时间，而系统调用的运行时间属于「系统」时间  
函数调用属于过程调用，开销较小，而系统调用需要切换到内核上下文环境然后切换回来，开销较大
### 对于默认处理的结构体，能用memcmp来进行比较吗？为什么？如果不能，该如何比较？
### C++中有哪些机制可以取代宏？
常量使用const替代实现  
类型使用using替代实现  
函数或代码块使用inline替代实现
### 手写一个有可变参数的函数？
```cpp
#include <stdarg.h>
int sum(int len, ...){
    //定义可变参数列表
    va_list vlist;
    int sum = 0;
    //设置可变参数起始位置，len为最后一个变量
    va_start(vlist, len);
    for(int i = 0; i < len; i++){
        //从可变参数列表中获取数据，第二个参数为参数类型
        sum += va_arg(vlist, int);
    }
    //清理
    va_end(vlist);
    return sum;
}
```
### 可靠信号与不可靠信号的区别？
在信号列表中所有信号值小于32的信号都是不可靠信号，不可靠信号在发送多次而没有被处理时，信号集合不会记录信号发送的次数，只能被算作一次  
在信号列表中所有信号值大于32的信号都是可靠信号，可靠信号在发送多次会加入到队列中，在处理该信号后，会从队列中取出下一个信号，信号不会丢失
### this指针调用成员变量时，堆栈会发生什么变化？
当成员函数调用时，指向对象的this指针作为隐藏参数首先入栈，然后其他参数从右往左入栈，this指针调用成员变量时，会将this指针指向的对象按照字节偏移，找到要访问的成员变量
### 实现一个shared_ptr类和auto_ptr类
### C++中可以继承string类吗？为什么？
可以被继承，这不是Java  
C++ 可以使用final关键字防止类被继承
### char \* const \*(\*next)()是什么？
一个指向返回值为char *const *，参数为空的函数指针
### 访问一个网页的过程，计算机发生了什么？
### 如何判断const所修饰的对象？ 
对于修饰普通类型
```cpp
const int val = 5;
//表示该类型之后所占空间内容不可再改变  
```
对于修饰指针变量
```cpp
//const在*左边表示修饰指针所指向的类型为常量
const int *pval = 5;
int const *pval = 5;
*pval = 10;/*error*/
//const在*右边表示修饰指针的值不可改变，不能再指向一块新的空间地址
int *const pval = 5;
pval = nullptr;/*error*/
```